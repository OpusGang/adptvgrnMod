from vapoursynth import core
import vapoursynth as vs
from vsutil import get_depth, get_y, split, plane
import fvsfunc as fvf
import math
from functools import partial


def adptvgrnMod(clip_in: vs.VideoNode, strength=0.25, cstrength=None, size=1, sharp=50, static=True, luma_scaling=12,
                grain_chroma=True, grainer=None, fade_edges=False, tv_range=True, protect_neutral=True, seed=-1,
                show_mask=False) -> vs.VideoNode:
    """
    Original header:
    Generates grain based on frame and pixel brightness. Details can be found here:
    https://kageru.moe/blog/article/adaptivegrain
    Strength is the strength of the grain generated by AddGrain, static=True for static grain, luma_scaling
    manipulates the grain alpha curve. Higher values will generate less grain (especially in brighter scenes),
    while lower values will generate more grain, even in brighter scenes.
    ====================================================================================================================
    This mod simply adds the size and sharpness features from havsfunc's GrainFactory3.
    Additionally, the option to process only luma is added. Requires YUV input.
    New:
    - Option to add your own graining function (i.e. grainer=lambda x: core.f3kdb.Deband(x, y=0, cr=0, cb=0, grainy=64,
      dynamic_grain=True, keep_tv_range=True, output_depth=16)
    - Fixed grain_chroma and added cstrength. Mod 2 sources with size=1 now work, too.
    - Attempts to use Rust implementation of mask whenever possible with fallback to numpy version.
    - Option to fade amount of grain added on edge values where grain raises/lowers average plane value.
      - Additional protect_neutral parameter to keep neutral chroma in blacks neutral.
    - Added seed option.
    """

    def m4(x):
        return 16 if x < 16 else math.floor(x / 4 + 0.5) * 4

    neutral = 1 << (get_depth(clip_in) - 1)
    clip = clip_in
    dpth = get_depth(clip_in)

    try:
        mask = core.adg.Mask(clip.std.PlaneStats(), luma_scaling)
    except AttributeError:
        import numpy as np
        def fill_lut(y):
            """
            Using horner's method to compute this polynomial:
            (1 - (1.124 * x - 9.466 * x² + 36.624 * x³ - 45.47 * x⁴ + 18.188 * x⁵)) ** ((y²) * luma_scaling) * 255
            Using the normal polynomial is about 2.5x slower during the initial generation.
            I know it doesn't matter as it only saves a few ms (or seconds at most), but god damn, just let me have
            some fun here, will ya? Just truncating (rather than rounding) the array would also half the processing
            time, but that would decrease the precision and is also just unnecessary.
            """
            x = np.arange(0, 1, 1 / (1 << 8))
            z = (1 - (x * (1.124 + x * (-9.466 + x * (36.624 + x * (-45.47 + x * 18.188)))))) ** (
                    (y ** 2) * luma_scaling)
            if clip.format.sample_type == vs.INTEGER:
                z = z * 255
                z = np.rint(z).astype(int)
            return z.tolist()

        lut = [None] * 1000
        for y in np.arange(0, 1, 0.001):
            lut[int(round(y * 1000))] = fill_lut(y)

        def generate_mask(n, f, clip):
            frameluma = round(f.props.PlaneStatsAverage * 999)
            table = lut[int(frameluma)]
            return core.std.Lut(clip, lut=table)

        luma = get_y(fvf.Depth(clip_in, 8)).std.PlaneStats()
        mask = core.std.FrameEval(luma, partial(generate_mask, clip=luma), prop_src=luma)

    cw = clip.width  # ox
    ch = clip.height  # oy

    if dpth != 8:
        mask = fvf.Depth(mask, bits=dpth)
    if show_mask:
        return mask

    sx = m4(cw / size) if size != 1 else cw
    sy = m4(ch / size) if size != 1 else ch
    sxa = m4((cw + sx) / 2)
    sya = m4((ch + sy) / 2)
    b = sharp / -50 + 1
    c = (1 - b) / 2
    if cstrength is None and grain_chroma is True:
        cstrength = .5 * strength
    elif cstrength != 0 and cstrength is not None and grain_chroma is False:
        raise ValueError("cstrength must be None or 0 if grain_chroma is False!")
    elif cstrength is None and not grain_chroma:
        cstrength = 0

    blank = core.std.BlankClip(clip, sx, sy, color=[neutral for i in split(clip)])
    if grainer is None:
        grained = core.grain.Add(blank, var=strength, uvar=cstrength, constant=static, seed=seed)
    else:
        grained = grainer(blank)
    if size != 1 and (sx != cw or sy != ch):
        if size > 1.5:
            grained = core.resize.Bicubic(grained, sxa, sya, filter_param_a=b, filter_param_b=c)
            grained = core.resize.Bicubic(grained, cw, ch, filter_param_a=b, filter_param_b=c)
        else:
            grained = core.resize.Bicubic(grained, cw, ch, filter_param_a=b, filter_param_b=c)

    if fade_edges:
        if tv_range:
            lo = 16 << (dpth - 8)
            hi = [235 << (dpth - 8), 240 << (dpth - 8)]
        else:
            lo = 0
            hi = 2 * [(1 << dpth) - 1]
        limit_expr = "x y {0} - abs - {1} < x y {0} - abs + {2} > or x y {0} - x + ?"
        grained = core.std.Expr([clip, grained], [limit_expr.format(
            neutral, lo, hi[0]), limit_expr.format(neutral, lo, hi[1])])
        if protect_neutral and (grain_chroma or cstrength > 0):
            max_value = round(2 * cstrength) << (dpth - 8)
            neutral_mask = core.std.Expr(split(fvf.Depth(clip.resize.Bilinear(format=vs.YUV444P16), dpth)),
                                         "x {0} <= x {1} >= or y {2} - abs {3} <= and z {2} - abs {3} <= and {4} {5} ?".format(
                                             lo + max_value,
                                             hi[1] - max_value, neutral,
                                             max_value, (1 << dpth) - 1, 0))
            grained = core.std.MaskedMerge(grained, clip, neutral_mask, planes=[1, 2])
    else:
        grained = core.std.MakeDiff(clip, grained)

    return core.std.MaskedMerge(clip_in, grained, mask)


def FrameType(n, clip, funcB=lambda x: x, funcP=lambda x: x, funcI=lambda x: x):
    if clip.get_frame(n).props._PictType.decode() == "B":
        return funcB(clip)
    elif clip.get_frame(n).props._PictType.decode() == "P":
        return funcP(clip)
    else:
        return funcI(clip)


def frmtpfnc(clip_in, funcB=lambda x: x, funcP=lambda x: x, funcI=lambda x: x):
    return core.std.FrameEval(clip_in, partial(FrameType, clip=clip_in, funcB=funcB, funcP=funcP, funcI=funcI))


def frmtpgrn(clip_in: vs.VideoNode, strength=[0.25, None, None], cstrength=[None, None, None], size=[1, None, None],
             sharp=[50, None, None], static=[True, None, None], luma_scaling=[12, None, None],
             grain_chroma=[True, None, None], grainer=[None, None, None], fade_edges=False, tv_range=True,
             protect_neutral=True, seed=-1,show_mask=False) -> vs.VideoNode:
    if isinstance(strength, int) or isinstance(strength, float):
        strength = 3 * [strength]
    if isinstance(cstrength, int) or isinstance(cstrength, float):
        cstrength = 3 * [cstrength]
    if isinstance(size, int) or isinstance(size, float):
        size = 3 * [size]
    if isinstance(sharp, int) or isinstance(sharp, float):
        sharp = 3 * [sharp]
    if isinstance(static, bool):
        static = 3 * [static]
    if isinstance(luma_scaling, int) or isinstance(luma_scaling, float):
        luma_scaling = 3 * [luma_scaling]
    if isinstance(grain_chroma, bool):
        grain_chroma = 3 * [grain_chroma]
    if callable(grainer):
        grainer = 3 * [grainer]

    return frmtpfnc(clip_in if not show_mask else get_y(clip_in),
                    funcB=lambda x: adptvgrnMod(x, strength[0], cstrength[0], size[0], sharp[0], static[0],
                                                luma_scaling[0], grain_chroma[0], grainer[0], fade_edges,
                                                tv_range, protect_neutral, seed, show_mask),
                    funcP=lambda x: adptvgrnMod(x, strength[1], cstrength[1], size[1], sharp[1], static[1],
                                                luma_scaling[1], grain_chroma[1], grainer[1], fade_edges, tv_range,
                                                protect_neutral, seed, show_mask),
                    funcI=lambda x: adptvgrnMod(x, strength[2], cstrength[2], size[2], sharp[2], static[2],
                                                luma_scaling[2], grain_chroma[2], grainer[2], fade_edges, tv_range,
                                                protect_neutral, seed, show_mask))
