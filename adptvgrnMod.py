import vapoursynth as vs
core = vs.core
from vsutil import get_depth, split, depth, scale_value
from typing import Callable
import math


def adptvgrnMod(
        clip_in: vs.VideoNode,
        strength: float | list[float] = 0.25,
        size: float | int = 1,
        sharp: int = 50,
        static: bool = False,
        luma_scaling: int = 12,
        grainer: Callable[[vs.VideoNode, ...], vs.VideoNode] | None = None,
        fade_edges: bool = True,
        tv_range: bool = True,
        lo: int | None = None,
        hi: int | None = None,
        protect_neutral: bool = True,
        seed: int = -1,
        show_mask: bool = False
        ) -> vs.VideoNode:
    """
    A modified kagefunc.adaptive_grain. New additions include GrainFactory3's grain size and sharpness, fading values
    near illegal range and protecting neutral grays.
    To access the graining without using the adaptive_grain mask, see sizedgrn.

    :param clip_in: Input clip.
    :param strength: Grainer strength. Use a list to specify [luma, chroma] graining. Default chroma grain is luma / 2.
    :param size: Grain size. >1 values are generated by upscaling from lower resolution, <1 by downscaling from higher.
    :param sharp: Grain sharpness. Determines b and c values in bicubic resampler used for grain size.
                  No effect if size = 1.
    :param static: Static or dynamic grain.
    :param luma_scaling: Luma-adaptive mask's sensitivity. Lower values will grain brights more, higher less.
    :param grainer: Custom grainer instead of AddGrain.
    :param fade_edges: Keeps grain from exceeding legal range. With this, values which go towards the neutral point but
                       would generate illegal values if they pointed in the other direction are also limited. This is
                       better at maintaining average values and prevents flickering pixels on OLEDs.
    :param tv_range: TV/PC legal range.
    :param lo: Overwrite legal range's minimums. Value is scaled from 8-bit to clip depth.
    :param hi: Overwrite legal range's maximums. Value is scaled from 8-bit to clip depth.
    :param protect_neutral: Disable chroma grain on neutral chroma.
    :param seed: Grain seed for AddGrain.
    :param show_mask: Show adaptive_grain mask.

    :returns: Grained clip.
    """

    dpth = get_depth(clip_in)

    try:
        from kagefunc import adaptive_grain
        mask = adaptive_grain(clip_in, luma_scaling=luma_scaling, show_mask=True)
    except ModuleNotFoundError:
        mask = core.adg.Mask(clip_in.std.PlaneStats(), luma_scaling)

    if get_depth(mask) != dpth:
        mask = depth(mask, dpth)
    if show_mask:
        return mask

    grained = sizedgrn(clip_in, strength, size, sharp, static, grainer, fade_edges, tv_range, lo, hi, protect_neutral,
            seed)

    return core.std.MaskedMerge(clip_in, grained, mask)


def sizedgrn(
        clip: vs.VideoNode,
        strength: float | list[float] = 0.25,
        size: float | int = 1,
        sharp: int = 50,
        static: bool = False,
        grainer: Callable[[vs.VideoNode, ...], vs.VideoNode] | None = None,
        fade_edges: bool = True,
        tv_range: bool = True,
        lo: int | None = None,
        hi: int | None = None,
        protect_neutral: bool = True,
        seed: int = -1,
        ) -> vs.VideoNode:
    """
    A grainer that includes GrainFactory3's grain size and sharpness, fading values near illegal range and protecting
    neutral grays.

    :param clip: Input clip.
    :param strength: Grainer strength. Use a list to specify [luma, chroma] graining. Default chroma grain is luma / 2.
    :param size: Grain size. >1 values are generated by upscaling from lower resolution, <1 by downscaling from higher.
    :param sharp: Grain sharpness. Determines b and c values in bicubic resampler used for grain size.
                  No effect if size = 1.
    :param static: Static or dynamic grain.
    :param grainer: Custom grainer instead of AddGrain.
    :param fade_edges: Keeps grain from exceeding legal range. With this, values which go towards the neutral point but
                       would generate illegal values if they pointed in the other direction are also limited. This is
                       better at maintaining average values and prevents flickering pixels on OLEDs.
    :param tv_range: TV/PC legal range.
    :param lo: Overwrite legal range's minimums. Value is scaled from 8-bit to clip depth.
    :param hi: Overwrite legal range's maximums. Value is scaled from 8-bit to clip depth.
    :param protect_neutral: Disable chroma grain on neutral chroma.
    :param seed: Grain seed for AddGrain.

    :returns: Grained clip.
    """

    dpth = get_depth(clip)
    def scale(v, chroma=False):
        return scale_value(v, 8, dpth, scale_offsets=True, chroma=chroma)
    neutral = [scale(128)] + 2 * [scale(128, True)]

    def m4(x):
        return 16 if x < 16 else math.floor(x / 4 + 0.5) * 4

    cw = clip.width  # ox
    ch = clip.height  # oy

    if size != 1:
        sx = m4(cw / size)
        sy = m4(ch / size)
    else:
        sx = cw
        sy = ch

    sxa = m4((cw + sx) / 2)
    sya = m4((ch + sy) / 2)
    b = sharp / -50 + 1
    c = (1 - b) / 2

    if not isinstance(strength, list):
        strength = [strength, .5 * strength]
    elif len(strength) > 2:
        raise ValueError("sizedgrn only supports 2 strength values")

    blank = core.std.BlankClip(clip, sx, sy, color=[neutral[_] for _ in range(clip.format.num_planes)])
    if grainer is None:
        grained = core.grain.Add(blank, var=strength[0], uvar=strength[1], constant=static, seed=seed)
    else:
        grained = grainer(blank)

    if size != 1 and (sx != cw or sy != ch):
        if size > 1.5:
            grained = core.resize.Bicubic(grained, sxa, sya, filter_param_a=b, filter_param_b=c)
        grained = core.resize.Bicubic(grained, cw, ch, filter_param_a=b, filter_param_b=c)

    if fade_edges:
        if lo is None:
            lo = [scale(16), scale(16, 1)] if tv_range else [0, scale(0, 1)]
        elif not isinstance(lo, list):
            lo = [scale(lo), scale(lo, 1)]

        if hi is None:
            hi = [scale(235), scale(240, 1)] if tv_range else [scale(255), scale(255, 1)]
        elif not isinstance(hi, list):
            hi = [scale(hi), scale(hi, 1)]

        limit_expr = "x y {0} - abs - {1} < x y {0} - abs + {2} > or x y {0} - x + ?"
        if clip.format.sample_type == vs.INTEGER:
            limit_expr = 2 * [limit_expr]
        else:
            limit_expr = [limit_expr, "x y abs + {2} > x abs y - {1} < or x x y + ?"]

        grained = core.std.Expr([clip, grained], [limit_expr[_].format(
            neutral[_], lo[_], hi[_]) for _ in range(0, clip.format.num_planes - 1)])

        if protect_neutral and strength[1] > 0 and clip.format.color_family == vs.YUV:
            format444 = core.query_video_format(vs.YUV, clip.format.sample_type, dpth, 0, 0)
            neutral_mask = clip.resize.Bicubic(format=format444)
            # disable grain if neutral chroma
            neutral_mask = core.std.Expr(split(neutral_mask),
                                         f"y {neutral[1]} = z {neutral[1]} = and {scale(255)} 0 ?"
                                         )
            grained = core.std.MaskedMerge(grained, clip, neutral_mask, planes=[1, 2])
    else:
        if clip.format.sample_type == vs.INTEGER:
            grained = core.std.MergeDiff(clip, grained)
        else:
            grained = core.std.Expr([clip, grained], [f"y {neutral[_]} - x +" for _ in range(clip.format.num_planes - 1)])

    return grained

